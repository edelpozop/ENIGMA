#include "platform/PlatformGenerator.hpp"
#include <iostream>
#include <sstream>

namespace enigma {

PlatformGenerator::PlatformGenerator() {
}

void PlatformGenerator::generatePlatform(const std::string& filename, 
                                          const ZoneConfig& config) {
    XMLWriter writer(filename);
    
    writer.writeDeclaration();
    writer.writeRaw("<!DOCTYPE platform SYSTEM \"https://simgrid.org/simgrid.dtd\">\n");
    writer.writeComment("Platform generated by ENIGMA Platform Generator");
    
    std::map<std::string, std::string> platformAttrs;
    platformAttrs["version"] = "4.1";
    writer.startElement("platform", platformAttrs);
    
    writeZone(writer, config, true);
    
    writer.endElement("platform");
    writer.close();
    std::cout << "Platform generated: " << filename << std::endl;
}

void PlatformGenerator::writeZone(XMLWriter& writer, const ZoneConfig& zone, bool /* isRoot */) {
    std::map<std::string, std::string> attrs;
    attrs["id"] = zone.id;
    attrs["routing"] = zone.routing;
    
    writer.startElement("zone", attrs);
    
    // Write subzones first (hierarchical structure)
    for (const auto& subzone : zone.subzones) {
        writeZone(writer, subzone, false);
    }
    
    // Write hosts
    for (const auto& host : zone.hosts) {
        writeHost(writer, host);
    }
    
    // Write clusters - either as native SimGrid clusters or expanded to hosts
    if (zone.use_native_clusters) {
        // Use SimGrid native <cluster> tags
        for (const auto& cluster : zone.clusters) {
            writeCluster(writer, cluster);
        }
    } else {
        // Expand clusters into individual hosts
        for (const auto& cluster : zone.clusters) {
            writeClusterAsHosts(writer, cluster);
        }
    }
    
    // Write links after hosts/clusters
    for (const auto& link : zone.links) {
        writeLink(writer, link);
    }
    
    // Generate inter-cluster links if using native clusters
    // Skip if this is a flat hybrid (detected by having edge/fog/cloud clusters)
    bool isFlatHybrid = false;
    if (zone.use_native_clusters && !zone.clusters.empty()) {
        bool hasEdge = false, hasFog = false, hasCloud = false;
        for (const auto& cluster : zone.clusters) {
            if (cluster.id.find("edge") != std::string::npos) hasEdge = true;
            if (cluster.id.find("fog") != std::string::npos) hasFog = true;
            if (cluster.id.find("cloud") != std::string::npos) hasCloud = true;
        }
        isFlatHybrid = (hasEdge && hasFog && hasCloud);
    }
    
    if (!isFlatHybrid && zone.use_native_clusters && zone.auto_interconnect && zone.clusters.size() > 1) {
        for (size_t i = 0; i < zone.clusters.size(); i++) {
            for (size_t j = i + 1; j < zone.clusters.size(); j++) {
                std::string link_id = "link_" + zone.clusters[i].id + "_to_" + zone.clusters[j].id;
                LinkConfig interClusterLink(link_id, "1GBps", "5ms");
                writeLink(writer, interClusterLink);
            }
        }
    }
    
    // Generate routes if necessary (must be AFTER links)
    if (zone.auto_interconnect) {
        if (zone.use_native_clusters && !zone.clusters.empty()) {
            // Native clusters: generate inter-cluster routes
            // Check if this is a flat hybrid (clusters directly in root with edge/fog/cloud naming)
            bool hasEdge = false, hasFog = false, hasCloud = false;
            for (const auto& cluster : zone.clusters) {
                if (cluster.id.find("edge") != std::string::npos) hasEdge = true;
                if (cluster.id.find("fog") != std::string::npos) hasFog = true;
                if (cluster.id.find("cloud") != std::string::npos) hasCloud = true;
            }
            
            if (hasEdge && hasFog && hasCloud) {
                // Flat hybrid: generate tiered inter-cluster routes
                generateFlatHybridRoutes(writer, zone);
            } else {
                // Single-tier: generate full mesh inter-cluster routes
                generateClusterInterconnection(writer, zone);
            }
        } else if (!zone.use_native_clusters && (zone.hosts.size() > 1 || !zone.clusters.empty())) {
            // Expanded hosts: generate full mesh routes
            generateFullRoutesWithClusters(writer, zone);
        } else if (zone.routing == "Full" && zone.hosts.size() > 1) {
            // Only standalone hosts: generate simple routes
            generateFullRoutes(writer, zone);
        }
        
        // Generate inter-zone routes if this zone has subzones with clusters
        if (!zone.subzones.empty()) {
            generateInterZoneRoutes(writer, zone);
        }
    }
    
    writer.endElement("zone");
}

void PlatformGenerator::writeHost(XMLWriter& writer, const HostConfig& host) {
    std::map<std::string, std::string> attrs;
    attrs["id"] = host.id;
    attrs["speed"] = host.speed;
    
    if (host.core_count > 1) {
        attrs["core"] = std::to_string(host.core_count);
    }
    
    if (!host.coordinates.empty()) {
        attrs["coordinates"] = host.coordinates;
    }
    
    writer.writeEmptyElement("host", attrs);
}

void PlatformGenerator::writeLink(XMLWriter& writer, const LinkConfig& link) {
    std::map<std::string, std::string> attrs;
    attrs["id"] = link.id;
    attrs["bandwidth"] = link.bandwidth;
    attrs["latency"] = link.latency;
    
    if (link.sharing_policy != "SHARED") {
        attrs["sharing_policy"] = link.sharing_policy;
    }
    
    writer.writeEmptyElement("link", attrs);
}

void PlatformGenerator::writeRoute(XMLWriter& writer, const std::string& src, 
                                    const std::string& dst,
                                    const std::vector<std::string>& links) {
    std::map<std::string, std::string> attrs;
    attrs["src"] = src;
    attrs["dst"] = dst;
    
    writer.startElement("route", attrs);
    
    for (const auto& link : links) {
        std::map<std::string, std::string> linkAttrs;
        linkAttrs["id"] = link;
        writer.writeEmptyElement("link_ctn", linkAttrs);
    }
    
    writer.endElement("route");
}

void PlatformGenerator::generateFullRoutes(XMLWriter& writer, const ZoneConfig& zone) {
    // Create routes between all hosts
    for (size_t i = 0; i < zone.hosts.size(); ++i) {
        for (size_t j = i + 1; j < zone.hosts.size(); ++j) {
            std::string linkId = "link_" + zone.hosts[i].id + "_" + zone.hosts[j].id;
            
            // Search for specific link, otherwise use generic one
            std::vector<std::string> routeLinks;
            bool linkFound = false;
            
            for (const auto& link : zone.links) {
                if (link.id.find(zone.hosts[i].id) != std::string::npos &&
                    link.id.find(zone.hosts[j].id) != std::string::npos) {
                    routeLinks.push_back(link.id);
                    linkFound = true;
                    break;
                }
            }
            
            if (!linkFound && !zone.links.empty()) {
                // Use first available link as shared link
                routeLinks.push_back(zone.links[0].id);
            }
            
            if (!routeLinks.empty()) {
                writeRoute(writer, zone.hosts[i].id, zone.hosts[j].id, routeLinks);
            }
        }
    }
}

void PlatformGenerator::generateFullRoutesWithClusters(XMLWriter& writer, const ZoneConfig& zone) {
    // Collect all hosts (both standalone and from clusters)
    std::vector<std::string> allHosts;
    
    // Add standalone hosts
    for (const auto& host : zone.hosts) {
        allHosts.push_back(host.id);
    }
    
    // Add all cluster nodes
    for (const auto& cluster : zone.clusters) {
        for (int i = 0; i < cluster.num_nodes; ++i) {
            allHosts.push_back(cluster.id + "_node_" + std::to_string(i));
        }
    }
    
    // Create a shared link for all hosts
    std::string sharedLinkId = zone.id + "_shared_link";
    if (zone.links.empty()) {
        // Create a default link if none exists
        LinkConfig defaultLink(sharedLinkId, "1GBps", "5ms");
        writeLink(writer, defaultLink);
    } else {
        sharedLinkId = zone.links[0].id;
    }
    
    // Create routes between all hosts
    for (size_t i = 0; i < allHosts.size(); ++i) {
        for (size_t j = i + 1; j < allHosts.size(); ++j) {
            writeRoute(writer, allHosts[i], allHosts[j], {sharedLinkId});
        }
    }
}

// Static helpers to create typical configurations

ZoneConfig PlatformGenerator::createEdgeZone(const std::string& id, int numDevices) {
    ZoneConfig zone(id, "Full");
    
    // Create edge devices
    for (int i = 0; i < numDevices; ++i) {
        std::string deviceId = "edge_device_" + std::to_string(i);
        zone.hosts.emplace_back(deviceId, "1Gf", 1);
    }
    
    // Create low-capacity shared link
    zone.links.emplace_back("edge_link", "125MBps", "5ms");
    
    return zone;
}

ZoneConfig PlatformGenerator::createFogZone(const std::string& id, int numNodes) {
    ZoneConfig zone(id, "Full");
    
    // Create fog nodes with more capacity than edge
    for (int i = 0; i < numNodes; ++i) {
        std::string nodeId = "fog_node_" + std::to_string(i);
        zone.hosts.emplace_back(nodeId, "10Gf", 4);
    }
    
    // Create medium-capacity links
    zone.links.emplace_back("fog_link", "1GBps", "2ms");
    
    return zone;
}

ZoneConfig PlatformGenerator::createCloudZone(const std::string& id, int numServers) {
    ZoneConfig zone(id, "Full");
    
    // Create cloud servers with high capacity
    for (int i = 0; i < numServers; ++i) {
        std::string serverId = "cloud_server_" + std::to_string(i);
        zone.hosts.emplace_back(serverId, "100Gf", 16);
    }
    
    // Create high-capacity links
    zone.links.emplace_back("cloud_link", "10GBps", "100us");
    
    return zone;
}

ZoneConfig PlatformGenerator::createHybridPlatform(int edgeDevices, int fogNodes, 
                                                     int cloudServers) {
    ZoneConfig root("hybrid_platform", "Full");
    
    // Create Edge layer
    auto edgeZone = createEdgeZone("edge_zone", edgeDevices);
    root.subzones.push_back(edgeZone);
    
    // Create Fog layer
    auto fogZone = createFogZone("fog_zone", fogNodes);
    root.subzones.push_back(fogZone);
    
    // Create Cloud layer
    auto cloudZone = createCloudZone("cloud_zone", cloudServers);
    root.subzones.push_back(cloudZone);
    
    // Create inter-layer links
    root.links.emplace_back("edge_to_fog", "500MBps", "10ms");
    root.links.emplace_back("fog_to_cloud", "5GBps", "50ms");
    
    return root;
}

// Cluster-based configurations
ZoneConfig PlatformGenerator::createEdgeWithClusters(const std::string& id,
                                                      const std::vector<ClusterConfig>& clusters) {
    ZoneConfig zone(id, "Full");
    zone.clusters = clusters;
    zone.auto_interconnect = true;
    return zone;
}

ZoneConfig PlatformGenerator::createFogWithClusters(const std::string& id,
                                                     const std::vector<ClusterConfig>& clusters) {
    ZoneConfig zone(id, "Full");
    zone.clusters = clusters;
    zone.auto_interconnect = true;
    return zone;
}

ZoneConfig PlatformGenerator::createCloudWithClusters(const std::string& id,
                                                       const std::vector<ClusterConfig>& clusters) {
    ZoneConfig zone(id, "Full");
    zone.clusters = clusters;
    zone.auto_interconnect = true;
    return zone;
}

ZoneConfig PlatformGenerator::createHybridWithClusters(
    const std::vector<ClusterConfig>& edgeClusters,
    const std::vector<ClusterConfig>& fogClusters,
    const std::vector<ClusterConfig>& cloudClusters) {
    
    ZoneConfig root("hybrid_platform", "Full");
    root.auto_interconnect = true;
    
    // Create Edge layer with clusters
    if (!edgeClusters.empty()) {
        auto edgeZone = createEdgeWithClusters("edge_zone", edgeClusters);
        root.subzones.push_back(edgeZone);
    }
    
    // Create Fog layer with clusters
    if (!fogClusters.empty()) {
        auto fogZone = createFogWithClusters("fog_zone", fogClusters);
        root.subzones.push_back(fogZone);
    }
    
    // Create Cloud layer with clusters
    if (!cloudClusters.empty()) {
        auto cloudZone = createCloudWithClusters("cloud_zone", cloudClusters);
        root.subzones.push_back(cloudZone);
    }
    
    // Create inter-layer links
    root.links.emplace_back("edge_to_fog", "500MBps", "10ms");
    root.links.emplace_back("fog_to_cloud", "5GBps", "50ms");
    
    return root;
}

ZoneConfig PlatformGenerator::createHybridWithClustersFlat(
    const std::vector<ClusterConfig>& edgeClusters,
    const std::vector<ClusterConfig>& fogClusters,
    const std::vector<ClusterConfig>& cloudClusters) {
    
    // Flat hierarchy: all clusters directly under root zone
    ZoneConfig root("hybrid_platform", "Full");
    root.use_native_clusters = true;
    
    // Add all clusters to root zone (no intermediate zones)
    root.clusters.insert(root.clusters.end(), edgeClusters.begin(), edgeClusters.end());
    root.clusters.insert(root.clusters.end(), fogClusters.begin(), fogClusters.end());
    root.clusters.insert(root.clusters.end(), cloudClusters.begin(), cloudClusters.end());
    
    // Create inter-cluster links
    // Edge to Fog links
    for (const auto& edge : edgeClusters) {
        for (const auto& fog : fogClusters) {
            std::string link_id = "link_" + edge.id + "_to_" + fog.id;
            root.links.emplace_back(link_id, "500MBps", "10ms");
        }
    }
    
    // Fog to Cloud links
    for (const auto& fog : fogClusters) {
        for (const auto& cloud : cloudClusters) {
            std::string link_id = "link_" + fog.id + "_to_" + cloud.id;
            root.links.emplace_back(link_id, "5GBps", "50ms");
        }
    }
    
    return root;
}

void PlatformGenerator::writeCluster(XMLWriter& writer, const ClusterConfig& cluster) {
    std::map<std::string, std::string> attrs;
    attrs["id"] = cluster.id;
    attrs["prefix"] = cluster.id + "_node_";
    attrs["suffix"] = "";
    attrs["radical"] = "0-" + std::to_string(cluster.num_nodes - 1);
    attrs["speed"] = cluster.node_speed;
    attrs["core"] = std::to_string(cluster.cores_per_node);
    attrs["bw"] = cluster.bandwidth;
    attrs["lat"] = cluster.latency;
    attrs["bb_bw"] = cluster.backbone_bw;
    attrs["bb_lat"] = cluster.backbone_lat;
    attrs["router_id"] = cluster.id + "_router";
    
    // Wrap cluster in its own zone for proper routing
    std::map<std::string, std::string> zone_attrs;
    zone_attrs["id"] = cluster.id + "_zone";
    zone_attrs["routing"] = "Cluster";
    
    writer.startElement("zone", zone_attrs);
    writer.writeEmptyElement("cluster", attrs);
    writer.endElement("zone");
}

void PlatformGenerator::writeClusterAsHosts(XMLWriter& writer, const ClusterConfig& cluster) {
    // Create all cluster nodes as individual hosts
    for (int i = 0; i < cluster.num_nodes; ++i) {
        std::string hostId = cluster.id + "_node_" + std::to_string(i);
        HostConfig host(hostId, cluster.node_speed, cluster.cores_per_node);
        writeHost(writer, host);
    }
    
    // Create cluster internal links
    std::string clusterLinkId = cluster.id + "_internal_link";
    LinkConfig clusterLink(clusterLinkId, cluster.bandwidth, cluster.latency);
    writeLink(writer, clusterLink);
}

void PlatformGenerator::generateClusterInterconnection(XMLWriter& writer, const ZoneConfig& zone) {
    // Create zoneRoutes between cluster zones (links already created in writeZone)
    for (size_t i = 0; i < zone.clusters.size(); i++) {
        for (size_t j = i + 1; j < zone.clusters.size(); j++) {
            std::string link_id = "link_" + zone.clusters[i].id + "_to_" + zone.clusters[j].id;
            
            // Create zoneRoute between cluster zones (using routers as gateways)
            std::map<std::string, std::string> zoneRoute_attrs;
            zoneRoute_attrs["src"] = zone.clusters[i].id + "_zone";
            zoneRoute_attrs["dst"] = zone.clusters[j].id + "_zone";
            zoneRoute_attrs["gw_src"] = zone.clusters[i].id + "_router";
            zoneRoute_attrs["gw_dst"] = zone.clusters[j].id + "_router";
            
            writer.startElement("zoneRoute", zoneRoute_attrs);
            
            std::map<std::string, std::string> link_ctn_attrs;
            link_ctn_attrs["id"] = link_id;
            writer.writeEmptyElement("link_ctn", link_ctn_attrs);
            
            writer.endElement("zoneRoute");
        }
    }
}

void PlatformGenerator::generateInterZoneRoutes(XMLWriter& writer, const ZoneConfig& zone) {
    // Generate routes between subzones (e.g., edge_zone -> fog_zone -> cloud_zone)
    // Each subzone should have at least one cluster to use its router as gateway
    
    // Mapeo de nombres de zonas a Ã­ndices
    std::map<std::string, int> zone_indices;
    for (size_t i = 0; i < zone.subzones.size(); i++) {
        zone_indices[zone.subzones[i].id] = i;
    }
    
    for (size_t i = 0; i < zone.subzones.size(); i++) {
        for (size_t j = i + 1; j < zone.subzones.size(); j++) {
            const auto& zone_i = zone.subzones[i];
            const auto& zone_j = zone.subzones[j];
            
            // Skip if either zone has no clusters (no gateway available)
            if (zone_i.clusters.empty() || zone_j.clusters.empty()) {
                continue;
            }
            
            // Use the first cluster's router as the gateway for each zone
            std::string gateway_i = zone_i.clusters[0].id + "_router";
            std::string gateway_j = zone_j.clusters[0].id + "_router";
            
            // Find appropriate link between these zones
            std::string link_id;
            bool link_found = false;
            
            // Check for links based on zone names
            if (zone_i.id.find("edge") != std::string::npos && 
                zone_j.id.find("fog") != std::string::npos) {
                link_id = "edge_to_fog";
                link_found = true;
            } else if (zone_i.id.find("fog") != std::string::npos && 
                       zone_j.id.find("cloud") != std::string::npos) {
                link_id = "fog_to_cloud";
                link_found = true;
            } else if (zone_i.id.find("edge") != std::string::npos && 
                       zone_j.id.find("cloud") != std::string::npos) {
                // Edge to cloud should go through fog, skip direct route
                continue;
            } else {
                // Generic fallback
                for (const auto& link : zone.links) {
                    if (link.id.find("to") != std::string::npos) {
                        link_id = link.id;
                        link_found = true;
                        break;
                    }
                }
            }
            
            if (link_found) {
                // Create zoneRoute between the subzones
                std::map<std::string, std::string> zoneRoute_attrs;
                zoneRoute_attrs["src"] = zone_i.id;
                zoneRoute_attrs["dst"] = zone_j.id;
                zoneRoute_attrs["gw_src"] = gateway_i;
                zoneRoute_attrs["gw_dst"] = gateway_j;
                
                writer.startElement("zoneRoute", zoneRoute_attrs);
                
                std::map<std::string, std::string> link_ctn_attrs;
                link_ctn_attrs["id"] = link_id;
                writer.writeEmptyElement("link_ctn", link_ctn_attrs);
                
                writer.endElement("zoneRoute");
            }
        }
    }
}

void PlatformGenerator::generateFlatHybridRoutes(XMLWriter& writer, const ZoneConfig& zone) {
    // For flat hybrid: all clusters are at same level with edge/fog/cloud naming
    // Generate zoneRoutes: edge->fog and fog->cloud (not direct edge->cloud)
    
    std::vector<const ClusterConfig*> edge_clusters, fog_clusters, cloud_clusters;
    
    // Classify clusters
    for (const auto& cluster : zone.clusters) {
        if (cluster.id.find("edge") != std::string::npos) {
            edge_clusters.push_back(&cluster);
        } else if (cluster.id.find("fog") != std::string::npos) {
            fog_clusters.push_back(&cluster);
        } else if (cluster.id.find("cloud") != std::string::npos) {
            cloud_clusters.push_back(&cluster);
        }
    }
    
    // Generate zoneRoutes: edge -> fog
    for (const auto* edge : edge_clusters) {
        for (const auto* fog : fog_clusters) {
            std::string link_id = "link_" + edge->id + "_to_" + fog->id;
            
            std::map<std::string, std::string> zoneRoute_attrs;
            zoneRoute_attrs["src"] = edge->id + "_zone";
            zoneRoute_attrs["dst"] = fog->id + "_zone";
            zoneRoute_attrs["gw_src"] = edge->id + "_router";
            zoneRoute_attrs["gw_dst"] = fog->id + "_router";
            
            writer.startElement("zoneRoute", zoneRoute_attrs);
            
            std::map<std::string, std::string> link_ctn_attrs;
            link_ctn_attrs["id"] = link_id;
            writer.writeEmptyElement("link_ctn", link_ctn_attrs);
            
            writer.endElement("zoneRoute");
        }
    }
    
    // Generate zoneRoutes: fog -> cloud
    for (const auto* fog : fog_clusters) {
        for (const auto* cloud : cloud_clusters) {
            std::string link_id = "link_" + fog->id + "_to_" + cloud->id;
            
            std::map<std::string, std::string> zoneRoute_attrs;
            zoneRoute_attrs["src"] = fog->id + "_zone";
            zoneRoute_attrs["dst"] = cloud->id + "_zone";
            zoneRoute_attrs["gw_src"] = fog->id + "_router";
            zoneRoute_attrs["gw_dst"] = cloud->id + "_router";
            
            writer.startElement("zoneRoute", zoneRoute_attrs);
            
            std::map<std::string, std::string> link_ctn_attrs;
            link_ctn_attrs["id"] = link_id;
            writer.writeEmptyElement("link_ctn", link_ctn_attrs);
            
            writer.endElement("zoneRoute");
        }
    }
    
    // Note: We intentionally skip direct edge->cloud routes
    // to force hierarchical communication through fog
}

} // namespace enigma




